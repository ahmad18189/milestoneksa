[
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Validate",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-12 11:14:36.496190",
  "module": "Milestoneksa",
  "name": "KSA Leave Validation (Leave Application)",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Leave Application",
  "script": "from frappe import _\nfrom frappe.utils import getdate\n\ndef get_days(doc):\n    if not doc.from_date or not doc.to_date:\n        frappe.throw(_(\"From Date and To Date are required.\"))\n    d1, d2 = getdate(doc.from_date), getdate(doc.to_date)\n    days = (d2 - d1).days + 1\n    if days <= 0:\n        frappe.throw(_(\"To Date must be on or after From Date.\"))\n    return days\n\ndef get_employee(doc):\n    return frappe.get_doc(\"Employee\", doc.employee)\n\ndef get_active_leave_period(company, on_date):\n    lp = frappe.db.sql(\"\"\"\n        select name, start_date, end_date from `tabLeave Period`\n        where company=%s and is_active=1 and %s between start_date and end_date\n        order by start_date desc limit 1\n    \"\"\", (company, on_date), as_dict=True)\n    if lp:\n        return lp[0]\n    lp = frappe.db.sql(\"\"\"\n        select name, start_date, end_date from `tabLeave Period`\n        where company=%s and is_active=1\n        order by start_date desc limit 1\n    \"\"\", (company,), as_dict=True)\n    return lp[0] if lp else None\n\ndef sum_days_for_type(emp, leave_type, period_name, exclude_name=None):\n    cond_excl = \"\" if not exclude_name else \"and la.name != %(exclude)s\"\n    res = frappe.db.sql(f\"\"\"\n        select sum(datediff(la.to_date, la.from_date)+1) as days\n        from `tabLeave Application` la\n        where la.docstatus=1 and la.employee=%(emp)s\n          and la.leave_type=%(lt)s and la.leave_period=%(lp)s\n          {cond_excl}\n    \"\"\", dict(emp=emp, lt=leave_type, lp=period_name, exclude=exclude_name), as_dict=True)\n    return int(res[0].days or 0)\n\ndef validate(doc, method=None):\n    # bilingual Leave Types defined inside validate()\n    LT = {\n        \"annual\":      \"Annual Leave | الإجازة السنوية\",\n        \"sick\":        \"Sick Leave | الإجازة المرضية\",\n        \"marriage\":    \"Marriage Leave | إجازة الزواج\",\n        \"bereavement\": \"Bereavement Leave | إجازة الوفاة\",\n        \"maternity\":   \"Maternity Leave | إجازة الأمومة/الوضع\",\n        \"paternity\":   \"Paternity Leave | إجازة الأبوة\",\n        \"hajj\":        \"Hajj Leave | إجازة الحج\",\n        \"exam\":        \"Exam Leave | إجازة الاختبارات\",\n    }\n\n    days = get_days(doc)\n    emp  = get_employee(doc)\n    lp   = get_active_leave_period(emp.company, doc.from_date)\n    if not lp:\n        frappe.throw(_(\"No active Leave Period found for the employee's company.\"))\n    doc.leave_period = lp.name\n\n    lt = doc.leave_type\n\n    # Annual – sanity only\n    if lt == LT[\"annual\"]:\n        if days < 1:\n            frappe.throw(_(\"Annual Leave must be at least 1 day.\"))\n        return\n\n    # Sick – <=120 per period\n    if lt == LT[\"sick\"]:\n        total = sum_days_for_type(doc.employee, lt, lp.name, exclude_name=doc.name if doc.name else None)\n        if total + days > 120:\n            frappe.throw(_(f\"Sick Leave exceeds 120 days in the active Leave Period. Used: {total}, adding: {days}.\"))\n        return\n\n    # Marriage – exactly 5; date + proof; once per service\n    if lt == LT[\"marriage\"]:\n        if days != 5:\n            frappe.throw(_(\"Marriage Leave must be exactly 5 days.\"))\n        if not doc.marriage_date:\n            frappe.throw(_(\"Marriage Date is required for Marriage Leave.\"))\n        if not doc.marriage_doc:\n            frappe.throw(_(\"Marriage proof attachment is required for Marriage Leave.\"))\n        exists = frappe.db.exists(\"Leave Application\", {\"employee\": doc.employee, \"leave_type\": lt, \"docstatus\": 1})\n        if exists and (not doc.name or exists != doc.name):\n            frappe.throw(_(\"Marriage Leave can be granted once during service.\"))\n        return\n\n    # Bereavement – exactly 5; relation + date + proof\n    if lt == LT[\"bereavement\"]:\n        if days != 5:\n            frappe.throw(_(\"Bereavement Leave must be exactly 5 days.\"))\n        if not doc.deceased_relation:\n            frappe.throw(_(\"Relation is required for Bereavement Leave.\"))\n        if not doc.death_date:\n            frappe.throw(_(\"Death Date is required for Bereavement Leave.\"))\n        if not doc.death_doc:\n            frappe.throw(_(\"Death proof attachment is required for Bereavement Leave.\"))\n        return\n\n    # Maternity – exactly 84; female; proof\n    if lt == LT[\"maternity\"]:\n        if emp.gender and emp.gender.lower() != \"female\":\n            frappe.throw(_(\"Maternity Leave is restricted to Female employees.\"))\n        if days != 84:\n            frappe.throw(_(\"Maternity Leave must be exactly 84 days.\"))\n        if not doc.childbirth_date:\n            frappe.throw(_(\"Childbirth Date is required for Maternity Leave.\"))\n        if not doc.maternity_doc:\n            frappe.throw(_(\"Hospital/medical proof is required for Maternity Leave.\"))\n        return\n\n    # Paternity – exactly 3; male; within 7 days of birth; proof\n    if lt == LT[\"paternity\"]:\n        if emp.gender and emp.gender.lower() != \"male\":\n            frappe.throw(_(\"Paternity Leave is restricted to Male employees.\"))\n        if days != 3:\n            frappe.throw(_(\"Paternity Leave must be exactly 3 days.\"))\n        if not doc.paternity_childbirth_date:\n            frappe.throw(_(\"Childbirth Date is required for Paternity Leave.\"))\n        child_date = getdate(doc.paternity_childbirth_date)\n        if abs((getdate(doc.from_date) - child_date).days) > 7:\n            frappe.throw(_(\"Paternity Leave must start within 7 days of the childbirth date.\"))\n        if not doc.paternity_doc:\n            frappe.throw(_(\"Birth proof attachment is required for Paternity Leave.\"))\n        return\n\n    # Hajj – <=15; service >=2y; once; declaration\n    if lt == LT[\"hajj\"]:\n        if days > 15:\n            frappe.throw(_(\"Hajj Leave cannot exceed 15 days.\"))\n        if not emp.date_of_joining:\n            frappe.throw(_(\"Employee Date of Joining is required to validate Hajj Leave.\"))\n        years = (getdate(doc.from_date) - getdate(emp.date_of_joining)).days // 365\n        if years < 2:\n            frappe.throw(_(\"Hajj Leave requires at least 2 years of continuous service.\"))\n        exists = frappe.db.exists(\"Leave Application\", {\"employee\": doc.employee, \"leave_type\": lt, \"docstatus\": 1})\n        if exists and (not doc.name or exists != doc.name):\n            frappe.throw(_(\"Hajj Leave can be granted only once during service.\"))\n        if not doc.hajj_declaration:\n            frappe.throw(_(\"Please confirm Hajj 'first time during service' declaration.\"))\n        return\n\n    # Exam – <=10 per period; inside window; proof\n    if lt == LT[\"exam\"]:\n        if not (doc.exam_start_date and doc.exam_end_date):\n            frappe.throw(_(\"Exam Start/End dates are required for Exam Leave.\"))\n        if getdate(doc.from_date) < getdate(doc.exam_start_date) or getdate(doc.to_date) > getdate(doc.exam_end_date):\n            frappe.throw(_(\"Requested Exam Leave must be within the exam window.\"))\n        if not doc.exam_doc:\n            frappe.throw(_(\"Exam proof attachment is required for Exam Leave.\"))\n        total = sum_days_for_type(doc.employee, lt, lp.name, exclude_name=doc.name if doc.name else None)\n        if total + days > 10:\n            frappe.throw(_(f\"Exam Leave exceeds 10 days in the active Leave Period. Used: {total}, adding: {days}.\"))\n        return\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Validate",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-08-19 09:11:08.861811",
  "module": "Milestoneksa",
  "name": "Employee code",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Employee",
  "script": "from frappe.utils import getdate, flt\n\ncompute_residence_total(doc)\nvalidate_residence_dates(doc)\nvalidate_sponsorship_dates(doc)\n\n\ndef compute_residence_total(doc):\n\t\"\"\"Recalculate total from child rows and set custom_total_cost.\"\"\"\n\ttotal = 0.0\n\tfor row in (doc.custom_residence_costs or []):\n\t\ttotal += flt(getattr(row, \"amount\", 0), 2)\n\tdoc.custom_total_cost = total\n\n\ndef validate_residence_dates(doc):\n\t\"\"\"Validate Employee custom residence start/end dates on the parent doc.\"\"\"\n\tstart = getattr(doc, \"custom_residence_start_date\", None)\n\tend = getattr(doc, \"custom_residence_end_date\", None)\n\n\t# If either is set, both must be set\n\tif bool(start) ^ bool(end):\n\t\tfrappe.throw(_(\"Residence period is incomplete. Please set both Start and End dates.\"))\n\n\tif start and end:\n\t\ts = getdate(start)\n\t\te = getdate(end)\n\t\tif e < s:\n\t\t\tfrappe.throw(\n\t\t\t\t_(\"Residence End Date cannot be before Start Date (Start: {0}, End: {1}).\")\n\t\t\t\t.format(s.strftime(\"%Y-%m-%d\"), e.strftime(\"%Y-%m-%d\"))\n\t\t\t)\n\n\ndef validate_sponsorship_dates(doc):\n\t\"\"\"\n\tValidate child 'Sponsorship Transfer' rows:\n\t- Required dates per row\n\t- End >= Start per row\n\t- No overlapping periods across rows (inclusive check)\n\t\"\"\"\n\trows = list(doc.get(\"custom_sponsorship_transfer\") or [])\n\tif not rows:\n\t\treturn\n\n\t# Per-row required & range checks\n\tfor r in rows:\n\t\tif not r.sponsorship_start_date or not r.sponsorship_end_date:\n\t\t\tfrappe.throw(_(\"Row #{0}: Sponsorship Start and End dates are required.\").format(r.idx))\n\n\t\ts = getdate(r.sponsorship_start_date)\n\t\te = getdate(r.sponsorship_end_date)\n\t\tif e < s:\n\t\t\tfrappe.throw(\n\t\t\t\t_(\"Row #{0}: Sponsorship End Date cannot be before Start Date (Start: {1}, End: {2}).\")\n\t\t\t\t.format(r.idx, s.strftime(\"%Y-%m-%d\"), e.strftime(\"%Y-%m-%d\"))\n\t\t\t)\n\n\t# Overlap detection (sort by start date, then ensure each starts after the previous ends)\n\tsortable = [\n\t\t(getdate(r.sponsorship_start_date), getdate(r.sponsorship_end_date), r)\n\t\tfor r in rows\n\t]\n\tsortable.sort(key=lambda x: (x[0], x[1]))\n\n\tprev_end = None\n\tprev_row = None\n\tfor s, e, r in sortable:\n\t\tif prev_end and s <= prev_end:\n\t\t\t# Overlap found (inclusive): current start is on/before previous end\n\t\t\tfrappe.throw(\n\t\t\t\t_(\"Sponsorship periods overlap between Row #{0} (ends {1}) and Row #{2} (starts {3}). \"\n\t\t\t\t  \"Please adjust the dates.\")\n\t\t\t\t.format(\n\t\t\t\t\tprev_row.idx,\n\t\t\t\t\tprev_end.strftime(\"%Y-%m-%d\"),\n\t\t\t\t\tr.idx,\n\t\t\t\t\ts.strftime(\"%Y-%m-%d\")\n\t\t\t\t)\n\t\t\t)\n\t\tprev_end = e\n\t\tprev_row = r\n\n\t# OPTIONAL: require residence period be covered by at least one sponsorship period\n\t# Uncomment if desired.\n\t# res_start = getattr(doc, \"custom_residence_start_date\", None)\n\t# res_end = getattr(doc, \"custom_residence_end_date\", None)\n\t# if res_start and res_end:\n\t# \trs, re = getdate(res_start), getdate(res_end)\n\t# \tcovered = any((s <= rs and re <= e) for s, e, _ in sortable)\n\t# \tif not covered:\n\t# \t\tfrappe.throw(\n\t# \t\t\t_(\"Residence period ({0} → {1}) is not fully covered by any single Sponsorship Transfer period.\")\n\t# \t\t\t.format(rs.strftime(\"%Y-%m-%d\"), re.strftime(\"%Y-%m-%d\"))\n\t# \t\t)\n",
  "script_type": "DocType Event"
 }
]